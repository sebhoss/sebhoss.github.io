---
layout: post
title: Clojure Java Interoperability
tags: [Clojure, Java, Interoperability]
---

p. Clojure has several "forms and macros":http://clojure.org/java_interop call Java code. However calling Clojure code from Java is not always so straight forward. The following post shows the different options currently available.

h2. Using @gen-class@

p. Clojure code can be "compiled":http://clojure.org/compilation to standard JVM bytecode using "gen-class":http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/gen-class.

h3. Adding static modifiers

p. Clojure imposes the notion of immutability. As such Clojure functions are/should be void of any state or side-effects and only operate and the given input. Therefore exporting Clojure functions as static Java methods makes sense. The following example defines a Clojure function, a corresponding Java-callable function and exports the Java function as a static Method in the class @com.example.Computation@.

{% highlight clojure %}
(ns com.example.computation
  (:gen-class
    :name com.example.Computation
    :methods [#^{:static true} [incrementRange [int] java.util.List]]))

(defn increment-range
  "Creates a sequence of numbers up to max and then increments them."
  [max]
  (map inc (take max (range))))

(defn -incrementRange
  "A Java-callable wrapper around the 'increment-range' function."
  [max]
  (increment-range max))
{% endhighlight %}

p. Note that the above definition could be replaced by @(range start end)@. The example is just used to show some more Clojure functions.

p. The Java wrapper has to follow the "standard rules":http://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.8 for method names. Therefore @increment-range@ has to be renamed to @incrementRange@ (or some similar name without the *-*).

p. Trying out this code you may notice that the returned list is raw, e.g. the method definition doesn't use generics. To solve this problem declare that the generated class @:implements@ a certain interface that exposes the desired method definition(s). You won't be able to declare your methods as static anymore, but get a generified method for all your Java needs.

p. Returning an array of something is also possible with the following construct @"[Ljava.lang.Object;"@. Need a 2-dim array? Just use @"[[Ljava.lang.Object;"@ (notice the extra @[@).

p. Instead of defining every Clojure function which should be exported twice (the real function + the Java wrapper), it is possible to use a macro to do that extra work automatically.

{% highlight clojure %}
(defn camel-case [input] 
  (let [words (clojure.string/split input #"[\s_-]+")] 
    (clojure.string/join (cons (clojure.string/lower-case (first words)) (map clojure.string/capitalize (rest words))))))

(defn java-name [clojure-name]
  (symbol (str "-" (camel-case (str clojure-name)))))

(defmacro defn* [name & decls]
  (let [java-name (java-name name)]
    `(do (defn ~name ~decls)
       (defn ~java-name ~decls))))
{% endhighlight %}

p. The macro @defn*@ replaces @defn@ and automatically creates a second function with a valid camel-cased Java method name. The macro is available as a "small library":https://github.com/sebhoss/def-clj at "Maven Central":http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.github.sebhoss%22%20a%3A%22def-clj%22 .

h2. Using the Clojure Runtime

p. Using @gen-class@ imposes certain limitations on calling Clojure code from Java. One of those are functions which make use of Clojure "parameter destructuring":http://clojure.org/special_forms#Special%20Forms--Binding%20Forms%20(Destructuring).

{% highlight java %}
Var require = RT.var("clojure.core", "require");
Symbol namespace = Symbol.intern("DESIRED.NAMESPACE.HERE");
Var function = RT.var("DESIRED.NAMESPACE.HERE", "DESIRED-FUNCTION");
Keyword keyword = Keyword.intern("REQUIRED-KEYWORD");

require.invoke(namespace);
Object result = function.invoke(keyword, VALUE);
{% endhighlight %}

p. The desired namespace has to be on the classpath for this to work. Alternativly it is possible to load an entire Clojure script, as shown in the following example:

{% highlight java %}
RT.loadResourceScript("interop/core.clj");
RT.var("interop.core", "print-string").invoke("hello world");
{% endhighlight %}

p. On a big project it is properly wise to move Java->Clojure interop code into helper classes/methods. Look "here":https://github.com/mikera/clojure-utils/blob/master/src/main/java/mikera/cljutils/Clojure.java for an example.
